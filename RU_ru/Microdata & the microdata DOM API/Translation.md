# Microdata & the microdata DOM API

## Введение

Одной из проблем, на решение которой был направлен HTML5, было повышение логичности (и, следовательно, машиночитаемости) разметки, о чем свидетельствует введение стандартных семантических элементов, таких как <header>, <nav> и <figure>. Это все хорошо, но иногда возникает потребность добавить определенные машиночитаемые атрибуты для элементов контента, так чтобы их можно бы использовать в каком-либо скрипте предсказуемо, даже если разметка используемая для различного контента различается между собой. Эта потребность уже удовлетворена, в определенной степени, с помощью простых и обратно совместимых [Микроформатов](http://microformats.org/), и с помощью более эзотерического [RDFa](http://www.w3.org/TR/xhtml-rdfa-primer/).

В связи с этим, нет ничего удивительного, что решение этой проблемы было добавлено в спецификацию HTML5 в виде спецификации [микроданных](http://www.whatwg.org/specs/web-apps/current-work/multipage/microdata.html)(далее Microdata), включающей в себя набор атрибутов, которые могут быть добавлены к любому элементу и связанное DOM API для обработки/агрегирования микроданных на странице.


Microdata пытается улучшить то, что мы уже имели в прошлом: обеспечить встроенный механизм, который также легко понять, как и микроформаты, и который позволяет обрабатывать данные без необходимости писать свой собственный парсер. Вы, конечно же, можете создать свой [собственный парсер Microdata для поддержки в браузерах без нативной поддержки Microdata DOM API, используя JavaScript](https://github.com/termi/Microdata-JS), если это необходимо. В этой статье мы пройдёмся по HTML-аттрибутам Microdata и синтаксису DOM API.

## HTML синтаксис

Microdata состоит из набора элементов, каждый из которых имеет набор свойств представленных парами ключ-значение. Собственно, как настоящие web-гики, давайте опишем себя в формате микроданных. Вы можете написать свой собственный пример, по моему образцу.

_Примечание: Вы можете проверить правильность синтаксиса Microdata с помощью [экспериментально HTML5-валидатора](http://html5.validator.nu/). Также вы можете открыть [мой пример использования Microdata](http://dev.opera.com/articles/view/microdata-and-the-microdata-dom-api/microdata_example.html) и поглядывать на него, пока читаете текст данной статьи._

Прежде всего, мы можем отметить любой подходящий элемент как контейнер элементов, используя **itemscope** атрибут

    <article itemscope>
    </article>


Очевидно, что вы должны выбрать элемент содержащий нужные вам данные, при этом, не важно, какие данные вы отмечаете. В данном случае, я размечу карточку биографии: первым свойством будет наше имя, а отметим мы его с помощью аттрибута **itemprop**:

    <article itemscope>
      <h2 itemprop="name">Chris Mills</h2>
    </article>


Атрибут **itemprop** выделяет элемент содержащий данные. Значение атрибута — это имя свойства, а содержимое элемента — это значение свойства. Давайте добавим еще несколько свойств, чтобы убедиться, что вы уловили суть:

    <article itemscope>
      <h2 itemprop="name">Chris Mills</h2>
      <ul>
        <li>Nationality: <span itemprop="nationality">British</span></li>
        <li>Age: <span itemprop="age">33</span></li>
        <li>Hair colour: <span itemprop="colour">Brown</span></li>
      </ul>
    </article>

В некоторых случаях, значением свойства является не текстовое содержимое элемента, а значение некоторого атрибута у того же элемента. Например:

 1. Для тега <media> значением свойства является значение атрибута «src».
 1. Для тега <a> — значение атрибута «href».
 1. Для тега <time> — значение атрибута «datetime».

(Прим. переводчика: значения других элементов можно посмотреть в [спецификации](http://www.w3.org/TR/html5/microdata.html#values))

С другой стороны, если значением свойства является URL, то оно должно быть выражено через соответствующий элемент, который указывает на или загружает внешний ресурс, например, через элемент <a>. Если значение свойства — дата или время (или оба сразу), то свойство должно быть выражено через элемент <time> и атрибут «datetime». Атрибут **itemprop** добавляется точно также, но, при этом, значением свойства будет значение атрибута, вместо текстового контента элемента.

Несколько примеров:

    <article itemscope>
      <h2 itemprop="name">Chris Mills</h2>
      <p><img itemprop="image" src="Chris-Mills.png" alt="Photo of Chris Mills - this is me"></p>
      <ul>
        <li>Nationality: <span itemprop="nationality">British</span></li>
        <li>Age: <span itemprop="age">33</span></li>
        <li>Date of birth: <time itemprop="birthday" datetime="1978-06-27">June 27th 1978</time></li>
        <li>Hair colour: <span itemprop="colour">Brown</span></li>
      </ul>
    </article>

Примечание: На момент публикации этой статьи (10 августа 2011), ведутся [разговоры](http://www.brucelawson.co.uk/2011/goodbye-html5-time-hello-data/) о замене элемента на элемент <data>, поэтому данный пример может потребовать изменений.

## Вложенные узлы Microdata

Вы также можете совершенно спокойно внедрять Microdata элементы (Прим. переводчика: далее, чтобы не запутаться в терминах: «узлы Microdata») внутри друг друга. Самый верхний узел Microdata помечается атрибутом **itemscope**, а затем любые вложенные узлы Microdata также помечаются атрибутом **itemscope**. Давайте добавим некоторую информацию о своей группе в карточку биографии:

    <article itemscope itemtype="http://example.org/biography">

      ...

      <li>
        <div itemscope itemprop="band">
          <h3>My band</h3>
          <ul>
            <li>Name: <span itemprop="name">Conquest of Steel</span></li>
            <li>Band: <span itemprop="style">Heavy metal</span></li>
            <li>Members: <span itemprop="size">5</span></li>
          </ul>
        </div>
      </li>

     ...

    </article>

## Разные свойства, одно имя; одно свойство, разные имена


Вы можете указать у нескольких элементов одно и тоже название свойства, например:

    <li>Members:
      <ul>
        <li itemprop="member">Claymore Clark</li>
        <li itemprop="member">DD Danger</li>
        <li itemprop="member">Dan Durrant</li>
        <li itemprop="member">Chris Mills</li>
        <li itemprop="member">Vic Victory</li>
      </ul>
    </li>


Результатом будет узел Microdata с пятью свойствами, все с именем «memeber» и каждое со своим значением.

И наоборот, вы также можете поместить несколько свойств в одном элементе, тем самым давая этим свойствам одинаковое значение:

    <li>Band: <span itemprop="style favouritemusic">Heavy metal</span></li>


Указание на свойства вне itemscope элемента


Могут быть случаи, когда вы хотите, чтобы ваши узлы Microdata включали свойства, которые на самом деле определены не в пределах этого пункта(элемента). Вы можете сделать это, ссылаясь на **ID** внешних свойств внутри атрибута **itemref**. Рассмотрим следующий пример, в котором я перенёс участников моей группы за пределы моего элемента, в отдельное место в html-разметки:

    <article>

      ...

        <li>
          <div itemscope itemprop="band" itemref="members">
            <h3>My band</h3>
            <ul>
              <li>Name: <span itemprop="name">Conquest of Steel</span></li>
              <li>Band: <span itemprop="style">Heavy metal</span></li>
              <li>Members: <span itemprop="bandsize">5</span></li>
            </ul>
          </div>
        </li>
      </ul>
    </article>
    
    <ul id="members">
        <li itemprop="member">Claymore Clark</li>
        <li itemprop="member">DD Danger</li>
        <li itemprop="member">Dan Durrant</li>
        <li itemprop="member">Chris Mills</li>
        <li itemprop="member">Vic Victory</li>
    </ul>


В этом случае «member» свойства находятся внутри элемента с идентификатором на который ссылается атрибут **itemref** нашего Microdata пункта.

_Примечание: Вы можете указать несколько ID в атрибуте itemref разделённых символом пробела. Например: itemref="members instruments gigdates"_

Определение словаря свойств для узлов Microdata, которые могут быть использованы в дальнейшем


Всё хорошо, пока вы используете свою Microdata разметку сами — вы сами определяете набор свойств для ваших узлов Microdata. Но, при совместной работе с другими веб-разработчиками возникает необходимость в определении словаря свойство для определённого узла Microdata. Вы можете сделать это, указав каждому узлу тип, используя **itemtype** атрибут. Значение этого атрибута имеет форму URL, ресурс на который ссылается данный URL может существовать, а может и не существовать. Хорошо, если вы указываете URL на реальную страницу в Интернете, которая информирует других пользователей о словаре свойств, но вы не обязаны этого делать.

Вернемся к нашему примеру:

    <article itemscope itemtype="http://example.org/biography">
      ...
      <div itemscope itemprop="band" itemtype="http://example.org/band" itemref="members">
        ...
      </div>
      ...
    </article>


Узел Microdata может иметь только один тип, а тип определяет словарь свойств. Таким образом, в нашем примере, элемент типа _http://example.org/biography_ имеет четыре свойства — name, style, bandsize и member. Это помогает избежать путаницы с аналогичным названием свойства. Можно также использовать Microdata для разметки информации о присяжных в суде, с аналогичным свойством itemprop=«member», но это будет другое свойство, т.к. узел Microdata имеет другой itemtype — http://example.org/jury», или любой другой по вашему выбору.

Вы должны хорошо подумать, какой словарь свойств вы будете использовать, чтобы выбрать надежный, гибкий и расширяемый: для получения дополнительной информации и советов, читайте раздел спецификации [Выбор имен при определении словарей](http://www.whatwg.org/specs/web-apps/current-work/multipage/microdata.html#selecting-names-when-defining-vocabularies). Вы также должны поискать в вебе, может быть кто-то уже написал подходящий словарь для ваших целей. Посмотрите раздел спецификации [словари Microdata](http://www.whatwg.org/specs/web-apps/current-work/multipage/microdata.html#mdvocabs) для получения информации о существующих словарях, перенесенных из микроформатов, таких как vCard и vEvent.

##Назначение глобального идентификатора для узла Midrodata


Некоторые вещи уже имеют идентификатор назначенный по мировым соглашениям об идентификаторах, таких как [ISBN](http://en.wikipedia.org/wiki/Isbn) для книг и [UPC](http://en.wikipedia.org/wiki/Universal_Product_Code) для продуктов в магазине. Некоторые словари Microdata поддерживают такие идентификаторы (вы должны сами выяснять такие вопросы, именно поэтому мы рекомендуем при написании собственных словарей свойств документировать их по URL-адресу указанному в атрибуте **itemtype**). Если вы используете подобные идентификаторы, укажите его в атрибуте **itemid** в том же элементе, где вы указали **itemscope** и **itemtype**. Кроулер или поисковый движок, который понимает подобную разметку (пока таких нету) поймёт, что ваш контент — это тот же ISBN/UPC объект, как и любой другой контент с каким же **itemid**. Далее они смогут плавно накапливать информацию до тех пор, пока сеть не обретет сознание и машины не восстанут.

Например, следующая разметка будет обработана, только при условии, что _http://example.com/book_ словарь явно указывает использовать ISBN идентификатор (больше деталей об этом позже):

    <article itemscope
        itemtype="http://example.com/book"
        itemid="urn:isbn:978-0321703521">

        <h2 itemprop="title">InterACT with web standards</h2>
        <p>Authors:</p>
        <ul>
            <li itemprop="author">Leslie Jensen-Inman</li>
            <li itemprop="author">Chris Mills</li>
            <li itemprop="author">Glenda Sims</li>
            <li itemprop="author">Aarron Walter</li>
      ...


## Microdata DOM API


Microdata становится еще более полезной, когда вы начинаете использовать её DOM API для манипуляций с узлами и их свойствами на странице используя javascript, возможно, для представления информации в поисковой манере или для доставки его в какое-либо другое приложение.

API очень простое — вы используете функцию document.getItems() для получения объекта Nodelist, содержащего все узлы Microdata на странице (Прим. переводчика: только все узлы **верхнего** уровня, т.е. не вложенные в другие узлы и не имеющие **itemprop** атрибута). Если вы вызываете функцию без аргументов, то вы получите список из всех узлов Microdata; или же, вы можете указать, какой itemtype вы ищите, передав его в качестве параметра вызова, в этом случае функция вернет Nodelist только с узлами Microdata у которых **itemtype** равен вашему параметру. Например:

    var biography = document.getItems("http://example.org/biography");



Вернёт биографический узел и сохранит его в переменную. После получения узла, вы можете манипулировать его свойствами через свойство **properties**:

    var biography = document.getItems("http://example.org/biography")[0];
    alert('Hi there ' + biography.properties['name'][0].textContent + '!');



И в этом нету ничего сложного, серьёзно. Вы можете найти больше примеров для изучения в разделе [Using the microdata DOM API](http://www.whatwg.org/specs/web-apps/current-work/multipage/microdata.html#using-the-microdata-dom-api) спецификации. Кроме того, [Philip Jägenstedt](http://blog.foolip.org/) создал довольно изящный [live microdata viewer](http://foolip.org/microdatajs/live/), который весьма полезен для проверки вашего кода, а также может быть использован для быстрой конвертации Microdata в различные форматы, например, JSON.

_Вы можете посмотреть на мой [пример использования Microdata](http://dev.opera.com/articles/view/microdata-and-the-microdata-dom-api/microdata_example.html). Также, зацените [набор тестов от Opera](http://w3c-test.org/html/tests/submission/Opera/microdata/001.html) для Microdata, мы только что запостили его в набор тестов W3C_

Наш краткий обзор микроданных завершился. Я надеюсь, что это помогло вам понять эту новую интересную технологию. Дайте нам знать, что вы думаете, и зацените нашу [экспериментальную сборку Opera с поддержкой микроданных](http://my.opera.com/desktopteam/blog/2011/07/27/latency-microdata-qresync).
